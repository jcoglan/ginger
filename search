#!/usr/bin/env node

'use strict'

const fs = require('fs')
const path = require('path')
const { parseArgs, inspect } = require('util')

function parse (manual) {
  let defs = manual.split('\n\n').map((text) => {
    let [word, ...def] = text.split(/\s/)
    let defWords = def.map(parseWord)

    let types = parseDef(defWords)
    let raw = defWords.map((w) => w.text)

    return types ? { word, types, raw } : null
  })

  defs = defs.filter((d) => d !== null)

  for (let def of defs) {
    def.count = defs.filter(({ raw }) => raw.includes(def.word)).length
  }

  return defs
}

function parseWord (word) {
  let text = word.replace(/[^a-z0-9]/ig, '')
  let punc = word.match(/[^a-z0-9]*$/)[0]
  return { text, punc }
}

function parseDef (words) {
  if (words[0].punc !== '.') return null

  let types = []
  let eos = true
  let lastType = null
  let lastDef = null

  for (let [i, { text, punc }] of words.entries()) {
    if (i < words.length - 1 && eos && punc === '.') {
      lastDef = []
      lastType = { type: text, defs: [lastDef] }
      types.push(lastType)
    } else if (/^[0-9]+$/.test(text)) {
      let n = parseInt(text, 10)
      lastDef = []
      lastType.defs[n - 1] = lastDef
    } else {
      lastDef.push({ text, punc })
    }
    eos = !eos && punc === '.'
  }

  return types
}

function matcher (patterns) {
  patterns = patterns.map(patternMatcher)

  return {
    match (words) {
      return words.some((word) => {
        return patterns.some((pat) => pat(word))
      })
    }
  }
}

function patternMatcher (pattern) {
  if (/^[a-z]*\.[a-z]*$/.test(pattern)) {
    let [start, end = ''] = pattern.split('.')
    return (word) => word.startsWith(start) && word.endsWith(end)
  }
  if (/^\.[a-z]+\.$/.test(pattern)) {
    let str = pattern.replace(/\./g, '')
    return (word) => word.includes(str)
  }
  return (word) => word === pattern
}

function printEntry ({ word, types, count }) {
  let head = bold(word) + ` [${count}]`
  console.log(head)

  for (let { type, defs } of types) {
    console.log(indent(1, type + '.'))

    for (let [i, def] of defs.entries()) {
      if (defs.length > 1) def = [{ text: `${i+1}`, punc: ':' }, ...def]

      def = def.map(({ text, punc }) => {
        return { len: text.length + punc.length, word: text + punc }
      })

      console.log(lineWrap(2, def))
    }
  }
  console.log()
}

function indent (n, str) {
  let pad = ''
  while (n--) pad += '    '
  return pad + str
}

function lineWrap (n, words) {
  let cols = process.stdout.columns || 80
  let limit = cols - 4 * (n + 2)
  let lines = []

  for (let { len, word } of words) {
    let last = lines.length - 1
    if (last === -1 || lines[last].len + len > limit) {
      lines.push({ len, text: word })
    } else {
      lines[last].len += 1 + len
      lines[last].text += ' ' + word
    }
  }

  return lines.map((line) => indent(n, line.text)).join('\n')
}

function bold (str) {
  return fmt(str, 1)
}

function ul (str) {
  return fmt(str, 4)
}

function fmt (str, n) {
  return `\x1b[${n}m${str}\x1b[0m`
}

let manual = fs.readFileSync(path.resolve(__dirname, 'manual.txt'), 'utf8')
let dict = parse(manual)

let { values: args } = parseArgs({
  options: {
    types:  { short: 'T', type: 'boolean' },
    type:   { short: 't', type: 'string' },
    def:    { short: 'd', type: 'string', multiple: true },
    use:    { short: 'u', type: 'string', multiple: true },
    sort:   { short: 's', type: 'string' }
  },
  strict: true
})

if (args.types) {
  let types = dict.flatMap(({ types }) => types.map((t) => t.type))
  let counts = new Map()

  for (let type of types) {
    counts.set(type, (counts.get(type) || 0) + 1)
  }

  let sorted = [...counts].sort(([x, a], [y, b]) => b - a)

  for (let [type, count] of sorted) {
    console.log(`\t${count}\t${type}`)
  }
  process.exit()
}

let results = dict.slice()

if (args.type) {
  results = results.filter(({ types }) => types.some((t) => t.type === args.type))
}

if (args.def) {
  let def = matcher(args.def)
  results = results.filter(({ word }) => def.match([word]))
}

if (args.use) {
  let use = matcher(args.use)
  results = results.filter(({ raw }) => use.match(raw))
}

if (args.sort === 'count') {
  results = results.sort((a, b) => b.count - a.count)
}

console.log(`found words: ${results.length}\n`)

for (let entry of results) {
  printEntry(entry)
}
